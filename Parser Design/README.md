# Parser Design
This repository contains the source code for a parser designed for a compiler using Yacc. It also provides some basic information on using Yacc to create parsers.

## Introduction
A parser is a component of a compiler that takes the stream of tokens generated by a lexer and converts it into a meaningful representation of the source code, such as an abstract syntax tree. Yacc (Yet Another Compiler-Compiler) is a tool for generating parsers in C or C++.

## Structure of a Lex Program

A Yacc program consists of three parts: declarations, grammar rules, and user-defined functions.
```yacc
%{
/* Declarations */
%}

%%
/* Grammar Rules */
%%

/* User Subroutine */
 
```

### Declarations

The declarations section is the place to define macros, global variables, and import header files written in C or C++. It is also possible to write any C code here, which will be copied into the generated source file. The declarations section is enclosed in `%{` and `%}`.

For example:
```yacc
%{
#include <stdio.h>
extern int yylex();
void yyerror(char *s);
int line_num = 1;
%}
```

### Grammar Rules
In the grammar rules section,  you define the grammar rules that the parser will match and the corresponding actions to be taken when a match is found. These rules are written in a format called Backus-Naur Form (BNF). The rules consist of a non-terminal symbol (a symbol that can be replaced with one or more expressions) followed by a colon, and a series of expressions separated by the pipe symbol (|) representing alternative productions. Each expression is made up of terminals (tokens generated by the lexer) and non-terminals. The rules section is enclosed in `%%`.

For example:
```yacc
%%
stmt : expr ';' { printf("Statement\n"); }
     | ID '=' expr ';' { printf("Assignment\n"); }
     ;
expr : term
     | expr '+' term { printf("Addition\n"); }
     | expr '-' term { printf("Subtraction\n"); }
     ;
term : factor
     | term '*' factor { printf("Multiplication\n"); }
     | term '/' factor { printf("Division\n"); }
     ;
factor : NUM { printf("Number\n"); }
       | ID { printf("Variable\n"); }
       | '(' expr ')' { printf("Expression\n"); }
       ;
%%
```

In this example, the grammar rules define the syntax for simple arithmetic expressions. The `stmt` rule matches a statement that consists of an expression followed by a semicolon or an assignment statement that consists of an identifier, an equals sign, an expression, and a semicolon. 
The `expr` rule matches an expression that consists of a term or one or more expressions separated by a plus or minus sign. 
The `term` rule matches a term that consists of a factor or one or more terms separated by a multiplication or division sign.
The `factor` rule matches a number, a variable, or an expression in parentheses.

### User-defined Functions

In the user-defined functions section, you can define any helper functions that you need for your parse. This section includes a `main` function. This section is for any additional C or C++ code that you want to include. The only required line is:
```c
main() { yyparse(); }
```
This is the main function for the resulting program. Yacc builds the `yyparse()` function that is called, and will do all of the work for you. Other functions here can be called from the grammar rules section.

For example:
```yacc
void yyerror(char *s) {
  fprintf(stderr, "Error: %s\n", s);
}

int main() {
  yyparse();
  return 0;
}
```


## Yacc Predefined

Yacc provides several predefined variables, functions, and options that can be used in your yacc program.

### Variables

- `$01`, `$1`, `$2`, ...: The semantic values of the matched symbols in the current rule. `$0` is the value of the whole rule, `$1` is the value of the first symbol in the rule, and so on.
- `$$`: The semantic value of the current rule. It is typically assigned a value in the action of the rule.
- `@n`:  The semantic value of the nth symbol in the previous rule. `@1` is the value of the first symbol in the previous rule, `@2` is the value of the second symbol, and so on.
- `yylval`: The semantic value of the current token.
- `yytext`: The matched string (i.e., the lexeme) of the current token.

### Functions

- `yyparse()`: The main function that parses the input according to the grammar rules.
- `yylex()`: Returns the next token from the input stream.
- `yyerror(char *s)`: Reports a syntax error and terminates the parsing process.
- `yywrap()`: Returns 1 to indicate the end of input.

### Options

There are several options available in yacc/bison. Here are some commonly used ones:

- `%start`: Specifies the starting symbol of the grammar.
- `%token`: Defines a terminal symbol.
- `%type`: Defines the type of a non-terminal symbol.
- `%left`, `%right`, `%nonassoc`: Specifies the associativity and precedence of operators.
- `%pure-parser`: Generates a pure parser without side effects.
- `%defines`: Generates a header file with the token and type definitions.
- `%debug`: Enables debug messages during parsing.
- `%union`: Defines the union of all the semantic values.

These options can be included at the top of the yacc file, before the rule definitions. These options affect how yacc generates the parser code and how it behaves during compilation and execution. For example:

```yacc
%token NUM ADD SUB MUL DIV LPAREN RPAREN
%left ADD SUB %left MUL DIV
%start expr
%pure-parser
%defines
%debug
```

 ## Usage: 
 To use a Yacc/Bison parser with a linked lexer, you first need to generate the lexer and parser code. You can generate the lexer code with Flex and the parser code with Bison.

Assuming you have a lexer file named `lexer.l` and a parser file named `parser.y`, you can generate the code with the following commands:
 ```
flex lexer.l
bison -d parser.y

 ```
 
 
