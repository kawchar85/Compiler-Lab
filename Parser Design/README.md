# Parser Design
This repository contains the source code for a parser designed for a compiler using Yacc. It also provides some basic information on using Yacc to create parsers.

## Introduction
A parser is a component of a compiler that takes the stream of tokens generated by a lexer and converts it into a meaningful representation of the source code, such as an abstract syntax tree. Yacc (Yet Another Compiler-Compiler) is a tool for generating parsers in C or C++.

## Structure of a Lex Program

A Yacc program consists of three parts: declarations, grammar rules, and user-defined functions.
```yacc
%{
/* Declarations */
%}

%%
/* Grammar Rules */
%%

/* User Subroutine */
 
```

### Declarations

The declarations section is the place to define macros, global variables, and import header files written in C or C++. It is also possible to write any C code here, which will be copied into the generated source file. The declarations section is enclosed in `%{` and `%}`.

For example:
```yacc
%{
#include <stdio.h>
extern int yylex();
void yyerror(char *s);
int line_num = 1;
%}
```

### Grammar Rules
In the grammar rules section, you define the rules for the grammar of your programming language. These rules are written in a format called Backus-Naur Form (BNF). The rules consist of a non-terminal symbol (a symbol that can be replaced with one or more expressions) followed by a colon, and a series of expressions separated by the pipe symbol (|) representing alternative productions. Each expression is made up of terminals (tokens generated by the lexer) and non-terminals. The rules section is enclosed in `%%`.

For example:
```yacc
%%
/* Production Rules */
stmt : expr ';' { printf("Statement\n"); }
     | ID '=' expr ';' { printf("Assignment\n"); }
     ;
expr : term
     | expr '+' term { printf("Addition\n"); }
     | expr '-' term { printf("Subtraction\n"); }
     ;
term : factor
     | term '*' factor { printf("Multiplication\n"); }
     | term '/' factor { printf("Division\n"); }
     ;
factor : NUM { printf("Number\n"); }
       | ID { printf("Variable\n"); }
       | '(' expr ')' { printf("Expression\n"); }
       ;
%%
```

In this example, the grammar rules define the syntax for simple arithmetic expressions. The `stmt` rule matches a statement that consists of an expression followed by a semicolon or an assignment statement that consists of an identifier, an equals sign, an expression, and a semicolon. 
The `expr` rule matches an expression that consists of a term or one or more expressions separated by a plus or minus sign. 
The `term` rule matches a term that consists of a factor or one or more terms separated by a multiplication or division sign.
The `factor` rule matches a number, a variable, or an expression in parentheses.

### User-defined Functions

In the user-defined functions section, you can define any helper functions that you need for your parse. This section includes a `main` function. This section is for any additional C or C++ code that you want to include. The only required line is:
```c
main() { yyparse(); }
```
This is the main function for the resulting program. Yacc builds the `yyparse()` function that is called, and will do all of the work for you. Other functions here can be called from the grammar rules section.

For example:
```yacc
void yyerror(char *s) {
  fprintf(stderr, "Error: %s\n", s);
}

int main() {
  yyparse();
  return 0;
}
```


## Lex Predefined

Flex provides several predefined variables, functions and options that can be used in your lex program.

### Variables

- `yytext`: The matched string (i.e., the lexeme) of the current rule.
- `yyleng`: The length of current matched strng.
- `yylineno`: The current line number.
- `yyin`: The input stream (i.e., the file or stdin).
- `yyout`: The output stream (i.e., the file or stdout).


### Functions

- `yylex()`: Returns the next token from the input stream.
- `yyrestart()`: Resets the input stream to a new file or stdin.
- `yywrap()`: Returns 1 to indicate the end of input.

### Options
 There are several options available in lex. Here are some commonly used ones:
  - `%option noyywrap`: tells lex not to generate code for handling end-of-file
  - `%option c++`: generates C++ code instead of C code
  - `%option outfile="filename"`: specifies the name of the output file
  - `%option yylineno`: generates code to track line numbers and assign them to the yylineno variable
  - `%option case-insensitive`: makes lex case-insensitive when matching patterns
  - `%option prefix="prefix"`: specifies a prefix to add to all function and variable names
  - `%option warn`: enables warnings during code generation
  - `%option debug`: generates debug information for the generated lexer
These options can be included at the top of the lex file, before the rule definitions. These options affect how lex generates the lexer code and how it behaves during compilation and execution. You can include multiple options separated by spaces, for example:
```lex
%option noyywrap c++
```
or
```lex
%option noyywrap
%option c++
```

 ## Usage: 
 ```
 flex sample1.l
 gcc lex.yy.c
 a OR a.exe OR a < input.txt > output.txt OR a.exe < input.txt > output.txt 
 ```
 
 
